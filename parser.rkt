#lang racket

;;  ____            _        _     ____                          
;; |  _ \ __ _  ___| | _____| |_  |  _ \ __ _ _ __ ___  ___ _ __ 
;; | |_) / _` |/ __| |/ / _ \ __| | |_) / _` | '__/ __|/ _ \ '__|
;; |  __/ (_| | (__|   <  __/ |_  |  __/ (_| | |  \__ \  __/ |   
;; |_|   \__,_|\___|_|\_\___|\__| |_|   \__,_|_|  |___/\___|_|   

(require "packets.rkt")
(require "logging.rkt")

(provide packet-parser)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SYNCHRONOUS PACKAGES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Sphero response packets are always of the following form.
;; +---------------------------------------+
;; | SOP1 | SOP2 | MRSP | SEQ | DLEN | CHK |
;; +---------------------------------------+

;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | SOP1 | Start of Packet #1                            | Always FFh                                                                               |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | SOP2 | Start of Packet #2                            | Set to FFh when this is an acknowledgement, FEh when this is an asynchronous message     |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | MRSP | Message Response ï¿¼                            | This is generated by the message decoder of the virtual device (refer to the             |
;; |      |                                               | appropriate appendix for a list of values)                                               |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | SEQ  | Sequence Number                               | Echoed to the client when this is a direct message response (set to 00h when SOP2 = FEh) |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | DLEN | Data Length                                   | The number of bytes following through the end of the packet                              |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | Data | Optional data in response to the              |                                                                                          |
;; |      | Command or based on "streaming" data settings |                                                                                          |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+
;; | CHK  | Checksum                                      | Packet checksum (as computed above)                                                      |
;; +------+-----------------------------------------------+------------------------------------------------------------------------------------------+

;; For now we assume only async packages. This means that the second
;; value (SOP2) will always be #xFE.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ASYNCHRONOUS PACKAGES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Sphero async response packets are always of the following form.
;;
;; Async packets do not have MRSP or SEQ bytes. The ID CODE
;; identifiers what type of data is arriving in the packet.
;;
;; +--------------------------------------------------------+
;; | SOP1 | SOP2 | ID_CODE | DLEN-HI | DLEN-LO | DATA | CHK |
;; +--------------------------------------------------------+

(define (read-single port)
  (let ((byte (read-byte port)))
    ;(display (format "*~a* " (hex-format byte)))
    (if (eof-object? byte)
        (read-single port)
        byte)))

;; Eats n bytes and returns a list where the first byte is in the head
;; of the list.
(define (eat-n-bytes port n acc)
  (if (> n 0)
      (let ((b (read-single port)))
        (eat-n-bytes port (- n 1) (cons b acc)))
      (reverse acc)))

;; Parses the SOP1 header field.
(define (parse-sop1 port)
  (let ((byte (read-single port)))
    ;; The first byte _has_ to be #xFF. That signifies the start of a
    ;; packet.
    (when (eq? #xFF byte)
        (parse-sop2 port))
    
    ;; Continue on to the next one.
    (parse-sop1 port)))

;; Parses the SOP2 header field.
(define (parse-sop2 port)
  (let ((byte (read-single port)))
    ;; #xFE indicates an async packet.
    (cond ((eq? #xFE byte)
           (parse-id-code port)))))

;; Assumes the following byte is an id_code, dispatches on that value.
(define (parse-id-code port)
  (let ((byte (read-single port)))
    (case byte
      ((eq? #x07 byte)
       (parse-cd port))
      (else (log-error (format "Unsupported ID_CODE: ~a" (hex-format byte)))))))

;; Parses the next packet as a two-byte size indication and then eats
;; all the data as well and returns it in a list. Note that multi-byte
;; numbers arive most-significant-bit first
;; (https://sdk.sphero.com/api-reference/api-packet-format/)
(define (parse-dlen port)
  (let* ((high (read-single port))
         (low  (read-single port))
         (len  (integer-bytes->integer (list->bytes (list high low)) #f #t 0  2)))
    (let ((data (eat-n-bytes port len '())))
      data)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Collision Detection

;; Reference implementation:
;; Collision: https://github.com/orbotix/sphero.js/blob/75ccac9caaa823da2ff816c27afac509c34dafc5/lib/parsers/async.js#L447-L503
;; +------------+------------+------------+-------------+------------+------------+-----------+------------+
;; |     X      |     Y      |     Z      |    Axis     | xMagnitude | yMagnitude |   Speed   | Timestamp  |
;; +------------+------------+------------+-------------+------------+------------+-----------+------------+
;; | 16-bit val | 16-bit val | 16-bit val | 8-bit field | 16-bit val | 16-bit val | 8-bit val | 32-bit val |
;; +------------+------------+------------+-------------+------------+------------+-----------+------------+


(define (parse-cd port)
  (log-info "Collision detected!")
  (let ((dlen (parse-dlen port)))
    (let* ((x     (parse-two-byte-int port))
           (y     (parse-two-byte-int port))
           (z     (parse-two-byte-int port))
           (axis  (read-single port))
           (xmag  (parse-two-byte-int port))
           (ymag  (parse-two-byte-int port))
           (speed (read-single port))
           (time  (eat-n-bytes port 4 '()))
           (chk   (read-single port)))
      (display "collision detected")
      (log-info (format "X: ~a | Y: ~a | Y: ~a | Axis: ~a | X-mag: ~a | Y-mag: ~a | Speed: ~a | Time: ~a" x y z axis xmag ymag speed time)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Helpers

;; Reads two bytes from the input and then assumes those form an
;; integer, returns that value.
(define (parse-two-byte-int port)
  (let* ((high (read-single port))
         (low  (read-single port))
         (len  (integer-bytes->integer (list->bytes (list high low)) #f #t 0  2)))
    len))

(define (debug port)
  (let ((byte (read-single port)))
    (display (format "*~a* " (hex-format byte))))
  (packet-parser port))

(define (packet-parser port)
  (parse-sop1 port))
